#!/bin/bash
echo "Bash version ${BASH_VERSION}..."

declare -a NAS_IMEI=( 3 9 1 8 3 6 6 2 0 0 0 0 0 0 )
# first value is for ENB, then UE0, UE1, etc.
declare -a MARKING=( 1 2 3 4 5 6 7 8 9 10 11 12 14 15 16 )
#declare -a PORT_RANGE=( 0:0 40000:40999 41000:41999 42000:42999 43000:43999 )

# BE CAREFULL MAY NOT WORK WITH OTHER VALUES (TO DO)
declare -i NUM_ENB=1

# Notes:
# We would like to remove the ipv4 addresses swap in the IP driver code for oai virtualized.
# Let's say oai0 has ipv4 @ 10.0.1.1, oai1 has ipv4 @ 10.0.2.2 etc.
# In the past when we generated some local traffic on the computer and wanted to make it go
# through for example oai1 to oai0, the ipv4 destination address was 10.0.2.1
#     meaning 10.0.2.2 wants to send a paquet to 10.0.1.1,
#     so ip_destination[2] has the digit corresponding to the source
#     so ip_destination[3] has the digit corresponding to the destination
# then in the driver we modified at the receiving side (oai0 here) the ip source and destination
# addresses in this way:
# Originating packet:                               SRC 10.0.X.X -> 10.0.2.1
# Resulting modified packet at the receiving side:  SRC 10.0.1.2 -> 10.0.1.1
# So the packet could be accepted by the device (same dest @) and the fake source was was recorded (1.2).
# So the response to this packet could return to the interface by where the request was pulled.
# But this solution lead to recompute checksums of packets in the driver.
#
# So here we describe a solution where packets are not modified by the IP driver but by the kernel:
#
#        +---------------+         +---------------+         +---------------+
#        |APP "VIRTUALLY"|         |APP "VIRTUALLY"|         |APP "VIRTUALLY"|   etc
#        |running on eNB |         |running on UE0 |         |running on UE1 |
#        |sending traffic|         |               |         |               |
#        | to UE 2       |         |               |         |               |
#        +---------------+         +---------------+         +---------------+
#           |        ^                |        ^                |        ^
#           |        |                |        |                |        |
#    Tx packet (n1)  |                |        |        Tx packet (n2)   |
#    XXXX->10.0.1.3  |                |        |         XXXX->10.0.1.3  |
#           |        |                |        |                |        |
#           | Rx packet (n2)          |        |                | Rx packet (n1)
#           | 10.0.1.3->10.0.1.1      |        |                | 10.0.3.1->10.0.3.3
#           V        |                V        |                V        |
#        +-----------------------------------------------------------------------------+
#        |  IPTABLES Table mangle chain OUTPUT TARGET MARK OPERATION setmark           |
#        |  On packets coming from applications                                        |
#        |-----------------------------------------------------------------------------|
#        |  Example for packet n1:                                                     |
#        |  iptables -t mangle -A OUTPUT --dst 10.0.1.3 -j MARK --set-mark 0x0103      |
#        +-----------------------------------------------------------------------------+
#           |        |                |        |                |        |
#    Tx packet (n1)  |                |        |                |        |
#    XXXX->10.0.1.3  |                |        |                |        |
#    mark 0x0103     |                |        |                |        |
#           |        |                |        |                |        |
#           V        |                V        |                V        |
#        +-----------------------------------------------------------------------------+
#        |  IPTABLES Table nat chain POSTROUTING TARGET SNAT OPERATION --to Fake IP SRC|
#        |  On packets coming from applications                                        |
#        |-----------------------------------------------------------------------------|
#        |  Example for packet n1:                                                     |
#        |  iptables -t nat -A POSTROUTING -m mark --mark 0x0103 -j SNAT --to 10.0.3.1 |
#        +-----------------------------------------------------------------------------+
#           |        |                |        |                |        |
#           |        |                |        |                | Rx packet (n1)
#           |        |                |        |                | 10.0.3.1->10.0.3.3
#           |        |                |        |                | mark 0x0103
#           |        |                |        |                |        |
#        +-----------------------------------------------------------------------------+
#        |  IPTABLES Table mangle chain PREROUTING TARGET MARK OPERATION setmark       |
#        |  On packets coming from applications                                        |
#        |-----------------------------------------------------------------------------|
#        |  Example for packet n1:                                                     |
#        |  iptables -t nat -A PREROUTING -m mark --mark 0x0103 -j DNAT --to 10.0.3.3  |
#        +-----------------------------------------------------------------------------+
#           |        ^                |        ^                |        ^
#           |        |                |        |                |        |
#    Tx packet (n1)  |                |        |                | Rx packet (n1)
#    10.0.3.1->10.0.1.3               |        |                | 10.0.3.1->10.0.1.3
#    mark 0x0103     |                |        |                | mark 0x0103
#           |        |                |        |                |        |
#        +-----------------------------------------------------------------------------+
#        |  IPTABLES Table mangle chain PREROUTING TARGET MARK OPERATION setmark       |
#        |  On packets coming from applications                                        |
#        |-----------------------------------------------------------------------------|
#        |  Example for packet n1:                                                     |
#        |  iptables -t mangle -A PREROUTING --dst 10.0.1.3 -j MARK --set-mark 0x0103  |
#        +-----------------------------------------------------------------------------+
#           |        ^                |        ^                |        ^
#           |        |                |        |                |   Rx packet (n1)
#           |        |                |        |                |   10.0.3.1->10.0.1.3
#           |        |                |        |                |        |
#           |10.0.1.1|                |10.0.2.2|                |10.0.3.3|
#           V        |                V        |                V        |
#          +----------+              +----------+              +----------+
#          |  oai0    |              | oai1     |              | oai2     |
#          |  (eNB)   |              | (UE0)    |              | (UE1)    |
#          +----------+              +----------+              +----------+

####################################################################################
#  HERE IS A DISPLAY OF THE CONTENT OF THE NAT TABLE FOR THE DESCRIBED SETTING
####################################################################################
# Chain PREROUTING (policy ACCEPT 1108 packets, 242K bytes)
#  pkts bytes target     prot opt in     out     source               destination
#     0     0 DNAT       all  --  *      *       0.0.0.0/0            0.0.0.0/0           mark match 0x102 to:10.0.2.2
#     0     0 DNAT       all  --  *      *       0.0.0.0/0            0.0.0.0/0           mark match 0x103 to:10.0.3.3
#     0     0 DNAT       all  --  *      *       0.0.0.0/0            0.0.0.0/0           mark match 0x201 to:10.0.1.1
#     0     0 DNAT       all  --  *      *       0.0.0.0/0            0.0.0.0/0           mark match 0x203 to:10.0.3.3
#     0     0 DNAT       all  --  *      *       0.0.0.0/0            0.0.0.0/0           mark match 0x301 to:10.0.1.1
#     0     0 DNAT       all  --  *      *       0.0.0.0/0            0.0.0.0/0           mark match 0x302 to:10.0.2.2
#
# Chain POSTROUTING (policy ACCEPT 2118 packets, 175K bytes)
#  pkts bytes target     prot opt in     out     source               destination
#     0     0 SNAT       all  --  *      *       0.0.0.0/0            0.0.0.0/0           mark match 0x102 to:10.0.2.1
#     0     0 SNAT       all  --  *      *       0.0.0.0/0            0.0.0.0/0           mark match 0x103 to:10.0.3.1
#     0     0 SNAT       all  --  *      *       0.0.0.0/0            0.0.0.0/0           mark match 0x201 to:10.0.1.2
#     0     0 SNAT       all  --  *      *       0.0.0.0/0            0.0.0.0/0           mark match 0x203 to:10.0.3.2
#     0     0 SNAT       all  --  *      *       0.0.0.0/0            0.0.0.0/0           mark match 0x301 to:10.0.1.3
#     0     0 SNAT       all  --  *      *       0.0.0.0/0            0.0.0.0/0           mark match 0x302 to:10.0.2.3
#
# Chain OUTPUT (policy ACCEPT 2133 packets, 186K bytes)
#  pkts bytes target     prot opt in     out     source               destination
####################################################################################
#  HERE IS A DISPLAY OF THE CONTENT OF THE MANGLE TABLE FOR THE DESCRIBED SETTING
####################################################################################
#root@hades:~# iptables -t mangle -nvL
# Chain PREROUTING (policy ACCEPT 2008K packets, 316M bytes)
#  pkts bytes target     prot opt in     out     source               destination
#     0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.1.2            MARK xset 0x102/0xffffffff
#     0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.1.3            MARK xset 0x103/0xffffffff
#     0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.2.1            MARK xset 0x201/0xffffffff
#     0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.2.3            MARK xset 0x203/0xffffffff
#     0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.3.1            MARK xset 0x301/0xffffffff
#     0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.3.2            MARK xset 0x302/0xffffffff
#
# Chain INPUT (policy ACCEPT 2008K packets, 316M bytes)
#  pkts bytes target     prot opt in     out     source               destination
#
# Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
#  pkts bytes target     prot opt in     out     source               destination
#
# Chain OUTPUT (policy ACCEPT 1989K packets, 331M bytes)
#  pkts bytes target     prot opt in     out     source               destination
#     0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.1.2            MARK xset 0x102/0xffffffff
#     0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.1.3            MARK xset 0x103/0xffffffff
#     0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.2.1            MARK xset 0x201/0xffffffff
#     0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.2.3            MARK xset 0x203/0xffffffff
#     0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.3.1            MARK xset 0x301/0xffffffff
#     0     0 MARK       all  --  *      *       0.0.0.0/0            10.0.3.2            MARK xset 0x302/0xffffffff
#
# Chain POSTROUTING (policy ACCEPT 1990K packets, 331M bytes)
#  pkts bytes target     prot opt in     out     source               destination
#
####################################################################################
# We also avoid the manipulation of ipv4 aRP packets by setting ourselves the neighbour cache:
####################################################################################
#root@hades:~# ip neigh show
#...
#10.0.3.1 dev oai1 lladdr 00:39:18:36:62:00 PERMANENT
#10.0.2.1 dev oai1 lladdr 00:39:18:36:62:00 PERMANENT
#10.0.1.1 dev oai1 lladdr 00:39:18:36:62:00 PERMANENT
#...
#10.0.1.2 dev oai0 lladdr 00:39:18:36:62:01 PERMANENT
#10.0.2.2 dev oai0 lladdr 00:39:18:36:62:01 PERMANENT
#10.0.3.2 dev oai0 lladdr 00:39:18:36:62:01 PERMANENT
#...
#10.0.1.3 dev oai0 lladdr 00:39:18:36:62:02 PERMANENT
#10.0.2.3 dev oai0 lladdr 00:39:18:36:62:02 PERMANENT
#10.0.3.3 dev oai0 lladdr 00:39:18:36:62:02 PERMANENT

#

declare -i NUM_MOBILES
declare -i INSTANCE
declare -i IP_SOURCE
declare -i IP_DEST
declare -i IP
declare -i RB_ID
declare -i CLASSIFIER_ID


iptables -t mangle --flush
iptables -t nat    --flush
iptables -t filter --flush


NUM_MOBILES=$1

for ((i=0 ; i < `expr $NUM_MOBILES + $NUM_ENB`; i++ ))
do
#     let i_p1=i+1
#
#     echo "ip rule del fwmark ${MARKING[$i]} table $i_p1"
#     ip rule del fwmark ${MARKING[$i]} table $i_p1
#     while [ "$?" -eq "0" ]
#     do
#         echo "ip rule del fwmark ${MARKING[$i]} table $i_p1"
#         ip rule del fwmark ${MARKING[$i]} table $i_p1
#     done
#
#     echo "ip route del table $i_p1"
#     ip route del table $i_p1

    echo "ip link set oai$i down"
    ip link set oai$i down
done



echo "Bringup eNB interface"


rmmod nasmesh
make  naslite_netlink_ether oaisim
#insmod $OPENAIR2_DIR/NAS/DRIVER/LITE/nasmesh.ko nas_IMEI=3,9,1,8,3,6,6,2,0,0,0,0,0,0
#insmod $OPENAIR2_DIR/NAS/DRIVER/LITE/nasmesh.ko nas_IMEI=${NAS_IMEI[0]},${NAS_IMEI[1]},${NAS_IMEI[2]},${NAS_IMEI[3]},${NAS_IMEI[4]},${NAS_IMEI[5]},${NAS_IMEI[6]},${NAS_IMEI[7]},${NAS_IMEI[8]},${NAS_IMEI[9]},${NAS_IMEI[10]},${NAS_IMEI[11]},${NAS_IMEI[12]}, ${NAS_IMEI[13]}
insmod $OPENAIR2_DIR/NAS/DRIVER/LITE/nasmesh.ko nas_IMEI=${NAS_IMEI[0]},${NAS_IMEI[1]},${NAS_IMEI[2]},${NAS_IMEI[3]},${NAS_IMEI[4]},${NAS_IMEI[5]},${NAS_IMEI[6]},${NAS_IMEI[7]},${NAS_IMEI[8]},${NAS_IMEI[9]},${NAS_IMEI[10]},${NAS_IMEI[11]},${NAS_IMEI[12]},${NAS_IMEI[13]}

ip addr add dev eth2 192.168.14.145/24 broadcast 192.168.14.255
ip route add 192.168.14.0/24 dev eth2
ip route add 224.0.0.160/28 dev eth2


#ip route add 224.0.0.160/28 dev eth2

NUM_MOBILES=$1
IP=1

########################
#                      #
#  CONFIGURE OAI IF    #
#                      #
########################
for ((i=0 ; i < `expr $NUM_MOBILES + $NUM_ENB`; i++ ))
do
    echo "ip link set oai$i broadcast ff:ff:ff:ff:ff:ff"
    ip link set oai$i broadcast ff:ff:ff:ff:ff:ff

    echo "ip link set oai$i up"
    ip link set oai$i up
    sleep 1

    echo "ifconfig oai$i 10.0.$IP.$IP netmask 255.255.255.0 broadcast 10.0.$IP.255"
    ifconfig oai$i 10.0.$IP.$IP netmask 255.255.255.0 broadcast 10.0.$IP.255

    sleep 1
    echo "ip addr add dev oai$i 2001:$IP::$IP/64"
    ip addr add dev oai$i 2001:$IP::$IP/64

    # avoid arp in virtualization
    for ((j=0 ; j <= $NUM_MOBILES ; j++ ))
    do
        if [[ $i -ne $j ]]
        then
            echo "ip neigh add to 10.0.$IP.$IP lladdr 00:${NAS_IMEI[0]}${NAS_IMEI[1]}:${NAS_IMEI[2]}${NAS_IMEI[3]}:${NAS_IMEI[4]}${NAS_IMEI[5]}:${NAS_IMEI[6]}${NAS_IMEI[7]}:${NAS_IMEI[8]}$i nud permanent dev oai$j"
            ip neighbour add to 10.0.$IP.$IP lladdr 00:${NAS_IMEI[0]}${NAS_IMEI[1]}:${NAS_IMEI[2]}${NAS_IMEI[3]}:${NAS_IMEI[4]}${NAS_IMEI[5]}:${NAS_IMEI[6]}${NAS_IMEI[7]}:${NAS_IMEI[8]}$i nud permanent dev oai$j
        fi
    done
    let IP=IP+1
done

########################
#                      #
#  MANGLE PACKETS      #
#                      #
########################
# for ((i=0 ; i < `expr $NUM_MOBILES + $NUM_ENB`; i++ ))
# do
#     let i_p1=i+1
#     echo "ip rule add fwmark ${MARKING[$i]} table $i_p1"
#     ip rule add fwmark ${MARKING[$i]} table $i_p1
#
#     #echo "ip route add table $i_p1 dev oai$i"
#     #ip route add table $i_p1 to 10.0. dev oai$i proto static
#     #echo "ip route add table $i_p1 dev oai$i"
#     #ip route add table $i_p1 dev oai$i
#     echo "ip route add table $i_p1 from 0.0.0.0/32 dev oai$i proto static"
#     ip route add table $i_p1 from 0.0.0.0/32 dev oai$i proto static
# done


# for ((i=0 ; i < $NUM_ENB; i++ ))
# do
#     let i_p1=i+1
#
#     echo "ip route add table $i_p1 dev oai$i"
#     ip route add table $i_p1 to 10.0. dev oai$i proto static
#     #echo "ip route add table $i_p1 dev oai$i"
#     #ip route add table $i_p1 dev oai$i
# done
#
# for ((ue=$NUM_ENB ; ue < `expr $NUM_ENB + $NUM_MOBILES` ; ue++))
# do
#     let IP_UE=$ue+1
#     echo "ip route add table 1 to 10.0.$IP_UE.$IP_UE dev oai0 proto static"
#     ip route add table 1 to 10.0.$IP_UE.$IP_UE dev oai0 proto static
#     echo "ip route add table 1 from 0.0.0.0/32 dev oai0 proto static"
#     ip route add table 1 from 0.0.0.0/32 dev oai0 proto static
# done
for ((src=0 ; src < `expr $NUM_ENB + $NUM_MOBILES` ; src++))
do
    let IP_SRC=$src+1
    for ((dst=0 ; dst < `expr $NUM_ENB + $NUM_MOBILES` ; dst++))
    do
        if [[ $src -ne $dst ]]
        then
            let IP_DST=$dst+1
            let marksrc=${MARKING[$src]}
            marksrc16=`printf '%02x' $marksrc`
            let markdst=${MARKING[$dst]}
            markdst16=`printf '%02x' $markdst`
            echo "iptables -t mangle -A OUTPUT --dst 10.0.$IP_SRC.$IP_DST -j MARK --set-mark 0x$marksrc16$markdst16"
            iptables -t mangle -A OUTPUT --dst 10.0.$IP_SRC.$IP_DST -j MARK --set-mark 0x$marksrc16$markdst16
            echo "iptables -t nat -A POSTROUTING -m mark --mark 0x$marksrc16$markdst16 -j SNAT --to 10.0.$IP_DST.$IP_SRC"
            iptables -t nat -A POSTROUTING -m mark --mark 0x$marksrc16$markdst16 -j SNAT --to 10.0.$IP_DST.$IP_SRC

            # we can use same mark since not same path (PREROUTING)
            echo "iptables -t mangle -A PREROUTING --dst 10.0.$IP_SRC.$IP_DST -j MARK --set-mark 0x$marksrc16$markdst16"
            iptables -t mangle -A PREROUTING --dst 10.0.$IP_SRC.$IP_DST -j MARK --set-mark 0x$marksrc16$markdst16
            echo "iptables -t nat -A PREROUTING    -m mark --mark 0x$marksrc16$markdst16 -j DNAT --to 10.0.$IP_DST.$IP_DST"
            iptables -t nat -A PREROUTING      -m mark --mark 0x$marksrc16$markdst16 -j DNAT --to 10.0.$IP_DST.$IP_DST
        fi
    done
done

# for ((ue=$NUM_ENB ; ue < `expr $NUM_ENB + $NUM_MOBILES` ; ue++))
# do
#     let IP_UE=$ue+1
#     # YEs actually this works (${MARKING[0]}) because we include only one eNB
#     echo "iptables -t mangle -A OUTPUT --dst 10.0.$IP_UE.$IP_UE -j MARK --set-mark ${MARKING[0]}"
#     iptables -t mangle -A OUTPUT --dst 10.0.$IP_UE.$IP_UE -j MARK --set-mark ${MARKING[0]}
#
#     echo "iptables -t nat -A POSTROUTING -m mark --mark ${MARKING[0]} -j SNAT --to 10.0.$IP_UE.$IP_UE"
#     iptables -t nat -A POSTROUTING -m mark --mark ${MARKING[0]} -j SNAT --to 10.0.$IP_UE.$IP_UE
#
#     for ((enb=0 ; enb < $NUM_ENB; enb++ ))
#     do
#         ## MANGLE PACKETS
#         ## RESULTS VISIBLE WITH " iptables -t mangle -nvL "
#         let IP_ENB=$enb+1
#
#         ## MARKING FOR ENBs
#         ## DST IP ADDR IS ENB ADDRESSES
#         echo "iptables -t mangle -A OUTPUT -p udp --dport ${PORT_RANGE[$ue]} --dst 10.0.$IP_ENB.$IP_ENB -j MARK --set-mark ${MARKING[$ue]}"
#         iptables -t mangle -A OUTPUT -p udp --dport ${PORT_RANGE[$ue]} --dst 10.0.$IP_ENB.$IP_ENB -j MARK --set-mark ${MARKING[$ue]}
#
#         echo "iptables -t mangle -A OUTPUT -p tcp --dport ${PORT_RANGE[$ue]} --dst 10.0.$IP_ENB.$IP_ENB -j MARK --set-mark ${MARKING[$ue]}"
#         iptables -t mangle -A OUTPUT -p tcp --dport ${PORT_RANGE[$ue]} --dst 10.0.$IP_ENB.$IP_ENB -j MARK --set-mark ${MARKING[$ue]}
#
#         let tos=16+$ue
#         tos16=`printf '%x' $tos`
#         echo "iptables -t mangle -A OUTPUT -p icmp  --dst 10.0.$IP_ENB.$IP_ENB -j MARK --set-mark ${MARKING[$ue]}"
#         iptables -t mangle -A OUTPUT -p icmp  --dst 10.0.$IP_ENB.$IP_ENB -j MARK --set-mark ${MARKING[$ue]}
#
# #         echo "iptables -t nat -A POSTROUTING -m mark --mark ${MARKING[$ue]} -j SNAT --to 10.0.$IP_ENB.$IP_ENB"
# #         iptables -t nat -A POSTROUTING -m mark --mark ${MARKING[$ue]} -j SNAT --to 10.0.$IP_ENB.$IP_ENB
#     done
# done
echo "########################################################################################"
echo "#          IPTABLES MANGLE                                                             #"
echo "########################################################################################"
iptables -t mangle -nvL
echo "########################################################################################"
echo "#          IPTABLES NAT                                                             #"
echo "########################################################################################"
iptables -t nat -nvL
echo "########################################################################################"
echo "#          RULES                                                                       #"
echo "########################################################################################"
ip rule show
# echo "########################################################################################"
# echo "#          ROUTES                                                                      #"
# echo "########################################################################################"
# for ((i=0 ; i < `expr $NUM_MOBILES + $NUM_ENB`; i++ ))
# do
#     let i_p1=i+1
#     echo -n " Table "$i_p1" : "; ip route show table $i_p1
# done
# echo "########################################################################################"

########################
#                      #
#  CONFIGURE RABS      #
#                      #
########################
# Loop Cx 0 -> NUM_MOBILES - 1 for configuring default RABS on eNB
CLASSIFIER_ID=0
for ((instance=0 ; instance < $NUM_ENB ; instance++ ))
do
    let IP_SRC=instance+1
    for ((cx=0 ; cx < $NUM_MOBILES ; cx++ ))
    do
        let IP_DEST=cx+2
        if [[ $IP_SRC -ne $IP_DEST ]]
        then
            # ON eNB
            let RB_ID=(cx*8)+3
            $OPENAIR2_DIR/NAS/DRIVER/LITE/RB_TOOL/rb_tool -a -c$cx -i$instance -f$CLASSIFIER_ID -z64 -s 10.0.$IP_DEST.$IP_SRC/32   -t 10.0.$IP_SRC.$IP_DEST/32   -r $RB_ID
            let CLASSIFIER_ID=CLASSIFIER_ID+2

            # ON UE
            let IP_SOURCE=instance+1
            let instance_ue=cx+$NUM_ENB
            RB_ID=3
            $OPENAIR2_DIR/NAS/DRIVER/LITE/RB_TOOL/rb_tool -a -c$instance -i$instance_ue -f$CLASSIFIER_ID -z64 -s 10.0.$IP_SRC.$IP_DEST/32 -t 10.0.$IP_DEST.$IP_SRC/32      -r $RB_ID
            let CLASSIFIER_ID=CLASSIFIER_ID+2

            # ON eNB
            echo "ip neigh add to 10.0.$IP_SRC.$IP_DEST lladdr 00:${NAS_IMEI[0]}${NAS_IMEI[1]}:${NAS_IMEI[2]}${NAS_IMEI[3]}:${NAS_IMEI[4]}${NAS_IMEI[5]}:${NAS_IMEI[6]}${NAS_IMEI[7]}:${NAS_IMEI[8]}$instance_ue nud permanent dev oai$instance"
            ip neighbour add to 10.0.$IP_SRC.$IP_DEST lladdr 00:${NAS_IMEI[0]}${NAS_IMEI[1]}:${NAS_IMEI[2]}${NAS_IMEI[3]}:${NAS_IMEI[4]}${NAS_IMEI[5]}:${NAS_IMEI[6]}${NAS_IMEI[7]}:${NAS_IMEI[8]}$instance_ue nud permanent dev oai$instance

            # ON UE
            echo "ip neigh add to 10.0.$IP_DEST.$IP_SRC lladdr 00:${NAS_IMEI[0]}${NAS_IMEI[1]}:${NAS_IMEI[2]}${NAS_IMEI[3]}:${NAS_IMEI[4]}${NAS_IMEI[5]}:${NAS_IMEI[6]}${NAS_IMEI[7]}:${NAS_IMEI[8]}$instance nud permanent dev oai$instance_ue"
            ip neighbour add to 10.0.$IP_DEST.$IP_SRC lladdr 00:${NAS_IMEI[0]}${NAS_IMEI[1]}:${NAS_IMEI[2]}${NAS_IMEI[3]}:${NAS_IMEI[4]}${NAS_IMEI[5]}:${NAS_IMEI[6]}${NAS_IMEI[7]}:${NAS_IMEI[8]}$instance nud permanent dev oai$instance_ue
        fi
    done
done

# for ((cx=0 ; cx <= `expr $NUM_MOBILES - 1` ; cx++ ))
# do
#     let IP_DEST=cx+2
#     let RB_ID=(cx*8)+3
#     $OPENAIR2_DIR/NAS/DRIVER/LITE/RB_TOOL/rb_tool -a -c$cx -i0 -f$CLASSIFIER_ID -z64 -s 10.0.1.1/32   -t 10.0.$IP_DEST.$IP_DEST/32   -r $RB_ID
#     let CLASSIFIER_ID=CLASSIFIER_ID+2
#     $OPENAIR2_DIR/NAS/DRIVER/LITE/RB_TOOL/rb_tool -a -c$cx -i0 -f$CLASSIFIER_ID -z64 -x 2001:1::1/128 -y 2001:$IP_DEST::$IP_DEST/128 -r $RB_ID
#     let CLASSIFIER_ID=CLASSIFIER_ID+2
#
#     # configuring default RABS on mobiles
#     for ((instance=1 ; instance <= $NUM_MOBILES ; instance++ ))
#     do
#         if [[ $instance -ne $cx ]]
#         then
#             let IP_SOURCE=instance+1
#             RB_ID=3
#             $OPENAIR2_DIR/NAS/DRIVER/LITE/RB_TOOL/rb_tool -a -c$cx -i$instance -f$CLASSIFIER_ID -z64 -s 10.0.$IP_SOURCE.$IP_SOURCE/32   -t 10.0.1.1/32      -r $RB_ID
#             let CLASSIFIER_ID=CLASSIFIER_ID+2
#             $OPENAIR2_DIR/NAS/DRIVER/LITE/RB_TOOL/rb_tool -a -c$cx -i$instance -f$CLASSIFIER_ID -z64 -x 2001:$IP_SOURCE::$IP_SOURCE/128 -y 2001:1::1/128 -r $RB_ID
#             let CLASSIFIER_ID=CLASSIFIER_ID+2
#         fi
#     done
# done



IP=1
for ((i=0 ; i < `expr $NUM_MOBILES + $NUM_ENB`; i++ ))
do
    # avoid arp in virtualization
    for ((j=0 ; j <= $NUM_MOBILES ; j++ ))
    do
        if [[ $i -ne $j ]]
        then
            echo "ip neigh add to 10.0.$IP.$IP lladdr 00:${NAS_IMEI[0]}${NAS_IMEI[1]}:${NAS_IMEI[2]}${NAS_IMEI[3]}:${NAS_IMEI[4]}${NAS_IMEI[5]}:${NAS_IMEI[6]}${NAS_IMEI[7]}:${NAS_IMEI[8]}$i nud permanent dev oai$j"
            ip neighbour add to 10.0.$IP.$IP lladdr 00:${NAS_IMEI[0]}${NAS_IMEI[1]}:${NAS_IMEI[2]}${NAS_IMEI[3]}:${NAS_IMEI[4]}${NAS_IMEI[5]}:${NAS_IMEI[6]}${NAS_IMEI[7]}:${NAS_IMEI[8]}$i nud permanent dev oai$j
        fi
    done
    let IP=IP+1
done

# echo "start the emulation with 1eNB and" $1 "UE"
echo "$OPENAIR_TARGETS/SIMU/USER/oaisim -a -u" $1 ">/dev/null"
# rm -f oai.log
$OPENAIR_TARGETS/SIMU/USER/oaisim -a -u $1 > /dev/null


echo "End"
