Index: ahbram.vhd
===================================================================
RCS file: /home/cvs/IDROMEL/grlib-eval/lib/gaisler/misc/ahbram.vhd,v
retrieving revision 1.1
diff -u -r1.1 ahbram.vhd
--- ahbram.vhd	5 Apr 2006 14:49:05 -0000	1.1
+++ ahbram.vhd	19 Apr 2006 18:03:32 -0000
@@ -25,6 +25,8 @@
 library techmap;
 use techmap.gencomp.all;
 
+use techmap.xcram.all;
+
 entity ahbram is
   generic (
     hindex  : integer := 0;
@@ -62,7 +64,12 @@
 signal ramsel : std_ulogic;
 signal write : std_logic_vector(3 downto 0);
 signal ramaddr  : std_logic_vector(abits-1 downto 0);
+signal ramaddrb : std_logic_vector(9 downto 0);
 signal ramdata  : std_logic_vector(31 downto 0);
+signal dip : std_logic_vector(1 downto 0);
+type dop_type is array(0 to 3) of std_logic_vector(1 downto 0);
+signal dop : dop_type;
+signal we32, we10 : std_logic;
 begin
 
   comb : process (ahbsi, r, rst, ramdata)
@@ -106,11 +113,40 @@
   ahbso.hconfig <= hconfig;
   ahbso.hindex  <= hindex;
 
-  ra : for i in 0 to 3 generate
-    aram :  syncram generic map (tech, abits, 8) port map (
-	clk, ramaddr, ahbsi.hwdata(i*8+7 downto i*8),
-	ramdata(i*8+7 downto i*8), ramsel, write(3-i)); 
-  end generate;
+-- This is the Gaisler's original instanciation. It always instanciate at least
+-- 4 banks, due to the need of byte-wide access...
+      --  ra : for i in 0 to 3 generate
+      --    aram :  syncram generic map (tech, abits, 8) port map (
+      --	clk, ramaddr, ahbsi.hwdata(i*8+7 downto i*8),
+      --	ramdata(i*8+7 downto i*8), ramsel, write(3-i));
+      --  end generate;
+
+-- ... This is for an 8 Kbytes memory in the form of 4 banks of 2 Kbytes each
+-- (each one byte-wide accessed). This was a waste of memory, since we only used
+-- 1 Kbytes in total.
+-- Anyway, we did that because of the necessity to access the array on a byte basis...
+      --  ra : for i in 0 to 3 generate
+      --    aram : RAMB16_S9 port map (ramdata(i*8+7 downto i*8), dop(i), ramaddrb, clk,
+      --                     ahbsi.hwdata(i*8+7 downto i*8), dip, ramsel, '0', write(3-i));
+      --  end generate;
+      --  ramaddrb(10 downto abits) <= (others => '0');  -- 1O downto 8...
+      --  ramaddrb(abits-1 downto 0) <= ramaddr;         --  7 downto 0...
+      --  dip <= (others => '0');
+
+-- ... Since we only use the AHBRAM for the boot prom feature, we DON'T need to access
+-- the array one byte after the other, so we could just map 1 bank of 2 Kbytes.
+-- But then again, to map Dhrystone .text section in the prom (at least, for test)
+-- we must increase the size of the array to 4 Kbytes (abits=10). Therefore, we
+-- use 2 banks of 2 Kbytes each, each one being half-word accessed. The write input port
+-- is an issue. So we use ORs, and forbid byte sized write accesses (dangerous...):
+  aram0: RAMB16_S18 port map (ramdata(15 downto 0), dop(0), ramaddrb, clk,
+                    ahbsi.hwdata(15 downto 0), dip, ramsel, '0', we32);
+  aram1: RAMB16_S18 port map (ramdata(31 downto 16), dop(1), ramaddrb, clk,
+                    ahbsi.hwdata(31 downto 16), dip, ramsel, '0', we10);
+  ramaddrb(9 downto 0) <= ramaddr(abits-1 downto 0);        -- 9 downto 0...
+  dip <= (others => '0');
+  we32 <= write(3) or write(2);
+  we10 <= write(1) or write(0);
 
   reg : process (clk)
   begin
