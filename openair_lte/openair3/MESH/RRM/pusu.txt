struct RRM_msg{
	unsigned char type;
	unsigned int length;
	void *	data;
}


struct neighbor_entry_RRM_to_CMM{
	char mac[IEEE80211_MAC_ADDR_LEN+1]; 	
	char mac[IEEE80211_MAC_ADDR_LEN+1]; 	
	int number_metric_uplink;
	int number_metric_downlink;
	extern struct QoS_metric **  metric_uplink;
	extern struct QoS_metric **  metric_downlink;
}

struct QoS_metric{
	unsigned char type;       
	unsigned int length;      
	struct_encoded_value *	encoded_value;    
}

struct encoded_value{
	unsigned char encoded_type;   
	void * value;                 
}



Hello,

Voici ce que je te propose:

Pour les informations generales du cluster (charge, temps de traversée...)
struct neighbor_entry_RRM_to_CMM{
> 	char mac[IEEE80211_MAC_ADDR_LEN+1] = @CH; 	
> 	char mac[IEEE80211_MAC_ADDR_LEN+1] = @CH; 	
> 	int number_metric_uplink = ignore;
> 	int number_metric_downlink = 1;
> 	struct QoS_metric **  metric_uplink;
> 	struct QoS_metric **  metric_downlink = load;
> }
Pour les informations d'attachement et detachement d'un MR
struct neighbor_entry_RRM_to_CMM{
> 	char mac[IEEE80211_MAC_ADDR_LEN+1] = @CH; 	
> 	char mac[IEEE80211_MAC_ADDR_LEN+1] = @MR; 	
> 	int number_metric_uplink = ignore;
> 	int number_metric_downlink = attachement=0 ou detachement=-1;
> 	struct QoS_metric **  metric_uplink;
> 	struct QoS_metric **  metric_downlink;
> }

Pour les informations generales sur les liens en intra (ceci ne concerne que les liens dont les deux extremités sont dans le cluster i.e. MRs attachés au CH)
struct neighbor_entry_RRM_to_CMM{
> 	char mac[IEEE80211_MAC_ADDR_LEN+1] = @MR ou @CH; 	
> 	char mac[IEEE80211_MAC_ADDR_LEN+1] = @MR ou @CH; 	
> 	int number_metric_uplink = nb1? ;
> 	int number_metric_downlink = nb2;
> 	struct QoS_metric **  metric_uplink = list1?;
> 	struct QoS_metric **  metric_downlink = list2;
> }

NB1 : pour nb1 et list1 on part du principe qu'on a pas de mesure uplink (je le laisse au cas où)
NB2 : la métrique choisie pour les liens est le RSSI (on discutera plus tard de la taille de la fenetre pour la moyenne) et pour le Cluster on se base sur une estimation de la charge (par exemple le nombre de slots vides dans la fenetre)

Ces informations sont du RRM(client) vers le CMM(serveur)

N'hesite pas à me recontacter si besoin est...

Stéphane
