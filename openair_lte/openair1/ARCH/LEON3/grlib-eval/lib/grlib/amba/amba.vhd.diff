Index: amba.vhd
===================================================================
RCS file: /home/cvs/openairinterface/arch/openair_CardBus_MIMO1/LEON3/grlib-eval/lib/grlib/amba/amba.vhd,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 amba.vhd
--- amba.vhd	26 Sep 2006 13:52:34 -0000	1.1.1.1
+++ amba.vhd	16 Mar 2007 17:25:17 -0000
@@ -1,14 +1,20 @@
-----------------------------------------------------------------------------
+------------------------------------------------------------------------------
 --  This file is a part of the GRLIB VHDL IP LIBRARY
---  Copyright (C) 2004 GAISLER RESEARCH
+--  Copyright (C) 2003, Gaisler Research
 --
 --  This program is free software; you can redistribute it and/or modify
 --  it under the terms of the GNU General Public License as published by
 --  the Free Software Foundation; either version 2 of the License, or
 --  (at your option) any later version.
 --
---  See the file COPYING for the full details of the license.
+--  This program is distributed in the hope that it will be useful,
+--  but WITHOUT ANY WARRANTY; without even the implied warranty of
+--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+--  GNU General Public License for more details.
 --
+--  You should have received a copy of the GNU General Public License
+--  along with this program; if not, write to the Free Software
+--  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 -----------------------------------------------------------------------------
 -- Package: 	amba
 -- File:	amba.vhd
@@ -22,6 +28,8 @@
 -- pragma translate_off
 use std.textio.all;
 -- pragma translate_on
+library grlib;
+use grlib.stdlib.all;
 
 package amba is
 
@@ -166,6 +174,7 @@
   subtype ahb_addr_type     is integer range 0 to 16#fff#;
   constant zx : std_logic_vector(31 downto 0) := (others => '0');
   constant zxirq : std_logic_vector(NAHBIRQ-1 downto 0) := (others => '0');
+  constant zy : std_logic_vector(0 to 31) := (others => '0');
 
   constant apb_none : apb_slv_out_type :=
     (zx, zxirq(NAHBIRQ-1 downto 0), (others => zx), 0);
@@ -173,6 +182,11 @@
    '0', "000", "000", "0000", zx, zxirq(NAHBIRQ-1 downto 0), (others => zx), 0);
   constant ahbs_none : ahb_slv_out_type := (
    '1', "00", zx, zx(15 downto 0), '0', zxirq(NAHBIRQ-1 downto 0), (others => zx), 0);
+  constant ahbs_in_none : ahb_slv_in_type := (
+   zy(0 to NAHBSLV-1), zx, '0', "00", "000", "000", zx,
+   "0000", '1', "0000", '0', zy(0 to NAHBAMR-1), '0', zxirq(NAHBIRQ-1 downto 0));
+
+  constant ahbsv_none : ahb_slv_out_vector := (others => ahbs_none);
 
   function ahb_device_reg(vendor : amba_vendor_type; device : amba_device_type;
 	cfgver : amba_cfgver_type; version : amba_version_type;
@@ -194,7 +208,7 @@
   return std_logic_vector;
 
   function ahb_slv_dec_cache(haddr : std_logic_vector(31 downto 0);
-                             ahbso : ahb_slv_out_vector)
+                             ahbso : ahb_slv_out_vector; cached : integer)
   return std_ulogic;
 
   function ahb_slv_dec_pfetch(haddr : std_logic_vector(31 downto 0);
@@ -218,9 +232,15 @@
     disirq  : integer range 0 to 1 := 0;  -- disable interrupt routing
     fixbrst : integer range 0 to 1 := 0;  -- support fix-length bursts
     debug   : integer range 0 to 2 := 2;  -- print config to console
-    fpnpen : integer range 0 to 1 := 0;   -- full PnP configuration decoding
+    fpnpen  : integer range 0 to 1 := 0;  -- full PnP configuration decoding
     icheck  : integer range 0 to 1 := 1;
-    devid   : integer := 0		  -- unique device ID
+    devid   : integer := 0;		  -- unique device ID
+    enbusmon    : integer range 0 to 1 := 0; --enable bus monitor
+    assertwarn  : integer range 0 to 1 := 0; --enable assertions for warnings 
+    asserterr   : integer range 0 to 1 := 0; --enable assertions for errors
+    hmstdisable : integer := 0; --disable master checks           
+    hslvdisable : integer := 0; --disable slave checks
+    arbdisable  : integer := 0  --disable arbiter checks
   );
   port (
     rst     : in  std_ulogic;
@@ -234,12 +254,16 @@
 
   component apbctrl
   generic (
-    hindex  : integer := 0;
-    haddr   : integer := 0;
-    hmask   : integer := 16#fff#;
-    nslaves : integer range 1 to NAPBSLV := NAPBSLV;
-    debug   : integer range 0 to 2 := 2;   -- print config to console
-    icheck  : integer range 0 to 1 := 1
+    hindex      : integer := 0;
+    haddr       : integer := 0;
+    hmask       : integer := 16#fff#;
+    nslaves     : integer range 1 to NAPBSLV := NAPBSLV;
+    debug       : integer range 0 to 2 := 2;   -- print config to console
+    icheck      : integer range 0 to 1 := 1;
+    enbusmon    : integer range 0 to 1 := 0;
+    asserterr   : integer range 0 to 1 := 0;
+    assertwarn  : integer range 0 to 1 := 0;
+    pslvdisable : integer := 0
   );
   port (
     rst     : in  std_ulogic;
@@ -269,6 +293,7 @@
     debug   : integer range 0 to 2 := 2;   -- report cores to console
     fpnpen  : integer range 0 to 1 := 0;   -- full PnP configuration decoding
     busndx  : integer range 0 to 3 := 0;
+    icheck  : integer range 0 to 1 := 1;    
     devid   : integer := 0		   -- unique device ID
   );
   port (
@@ -282,13 +307,71 @@
   end component;
 
   component ahbdefmst
-    generic ( hindex : integer range 0 to NAHBMST-1);
+    generic ( hindex : integer range 0 to NAHBMST-1 := 0);
     port ( ahbmo  : out ahb_mst_out_type);
   end component;
 
-
 -- pragma translate_off
 
+  component ahbmon is
+  generic(
+    asserterr   : integer range 0 to 1 := 1;
+    assertwarn  : integer range 0 to 1 := 1;
+    hmstdisable : integer := 0;
+    hslvdisable : integer := 0;
+    arbdisable  : integer := 0;
+    nahbm       : integer range 0 to NAHBMST := NAHBMST;
+    nahbs       : integer range 0 to NAHBSLV := NAHBSLV
+  );
+  port(
+    rst         : in std_ulogic;
+    clk         : in std_ulogic;
+    ahbmi       : in ahb_mst_in_type;
+    ahbmo       : in ahb_mst_out_vector;
+    ahbsi       : in ahb_slv_in_type;
+    ahbso       : in ahb_slv_out_vector;
+    err         : out std_ulogic);
+  end component;
+
+  component apbmon is
+  generic(
+    asserterr   : integer range 0 to 1 := 1;
+    assertwarn  : integer range 0 to 1 := 1;
+    pslvdisable : integer := 0;
+    napb        : integer range 0 to NAPBSLV := NAPBSLV
+  );
+  port(
+    rst         : in std_ulogic;
+    clk         : in std_ulogic;
+    apbi        : in apb_slv_in_type;
+    apbo        : in apb_slv_out_vector;
+    err         : out std_ulogic);
+  end component;
+  
+  component ambamon is
+    generic(
+      asserterr   : integer range 0 to 1 := 1;
+      assertwarn  : integer range 0 to 1 := 1;
+      hmstdisable : integer := 0;
+      hslvdisable : integer := 0;
+      pslvdisable : integer := 0;
+      arbdisable  : integer := 0;
+      nahbm       : integer range 0 to NAHBMST := NAHBMST;
+      nahbs       : integer range 0 to NAHBSLV := NAHBSLV;
+      napb        : integer range 0 to NAPBSLV := NAPBSLV
+    );
+    port(
+      rst        : in std_ulogic;
+      clk        : in std_ulogic;
+      ahbmi      : in ahb_mst_in_type;
+      ahbmo      : in ahb_mst_out_vector;
+      ahbsi      : in ahb_slv_in_type;
+      ahbso      : in ahb_slv_out_vector;
+      apbi       : in apb_slv_in_type;
+      apbo       : in apb_slv_out_vector;
+      err        : out std_ulogic);
+  end component;
+  
   subtype vendor_description is string(1 to 24);
   subtype device_description is string(1 to 31);
   type device_table_type is array (0 to 1023) of device_description;
@@ -369,21 +452,29 @@
   end;
 
   function ahb_slv_dec_cache(haddr : std_logic_vector(31 downto 0);
-                             ahbso : ahb_slv_out_vector)
+                             ahbso : ahb_slv_out_vector; cached : integer)
   return std_ulogic is
     variable hcache : std_ulogic;
+    variable ctbl : std_logic_vector(15 downto 0);
   begin
-    hcache := '0';
-    for i in 0 to NAHBSLV-1 loop
-      for j in NAHBAMR to NAHBCFG-1 loop
-        if ahbso(i).hconfig(j)(16) = '1' then
-          if (haddr(31 downto 20) and ahbso(i).hconfig(j)(15 downto 4)) =
-            (ahbso(i).hconfig(j)(31 downto 20) and ahbso(i).hconfig(j)(15 downto 4)) then
-            hcache := '1';
+    hcache := '0'; ctbl := (others => '0');
+    if cached = 0 then
+      for i in 0 to NAHBSLV-1 loop
+        for j in NAHBAMR to NAHBCFG-1 loop
+          if (ahbso(i).hconfig(j)(16) = '1') and 
+		(ahbso(i).hconfig(j)(15 downto 4) /= "000000000000")
+	  then
+            if (haddr(31 downto 20) and ahbso(i).hconfig(j)(15 downto 4)) =
+              (ahbso(i).hconfig(j)(31 downto 20) and ahbso(i).hconfig(j)(15 downto 4)) then
+              hcache := '1';
+            end if;
           end if;
-        end if;
+        end loop;
       end loop;
-    end loop;
+    else
+      ctbl := conv_std_logic_vector(cached, 16);
+      hcache := ctbl(conv_integer(haddr(31 downto 28)));
+    end if;
     return(hcache);
   end;
 
